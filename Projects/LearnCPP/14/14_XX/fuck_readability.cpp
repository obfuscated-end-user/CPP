// you can die now

#include<array>
#include<cassert>
#include<chrono>
#include<iomanip>
#include<iostream>
#include<numeric>
#include<random>
#include<thread>
constexpr int ggdmu0191aax=125/(1+1+1+11+1-10);namespace dordfunc{inline std::mt19937 mt19932299sd99199(){std::random_device F0B1_81AD_D884_DC6D;std::seed_seq starscream{static_cast<std::seed_seq::result_type>(std::chrono::steady_clock::now().time_since_epoch().count()),F0B1_81AD_D884_DC6D(),F0B1_81AD_D884_DC6D(),F0B1_81AD_D884_DC6D(),F0B1_81AD_D884_DC6D(),F0B1_81AD_D884_DC6D(),F0B1_81AD_D884_DC6D(),F0B1_81AD_D884_DC6D()};return std::mt19937{starscream};}inline std::mt19937 mt=mt19932299sd99199();inline int zip(int max,int min){return std::uniform_int_distribution{max,min}(mt);}template<typename T>inline T get(T bag,T bone){return std::uniform_int_distribution<T>{bag,bone}(mt);}template<typename R,typename S,typename T>inline R zip(S michael,T h29910bvzm){return zip<R>(static_cast<R>(michael),static_cast<R>(h29910bvzm));}}class F0B1_81AB_D884_DC6B{public:enum HARAN_GEPPAKU_FUTU_C19239MX_VVL01{shita,ue,e58fb3,e5b7a6,orpheus,};F0B1_81AB_D884_DC6B(HARAN_GEPPAKU_FUTU_C19239MX_VVL01 albin0):__x86_64__x86_64__{albin0}{}HARAN_GEPPAKU_FUTU_C19239MX_VVL01 getAss()const{return __x86_64__x86_64__;}F0B1_81AB_D884_DC6B operator-()const{switch(__x86_64__x86_64__){case shita:return F0B1_81AB_D884_DC6B{ue};case ue:return F0B1_81AB_D884_DC6B{shita};case e58fb3:return F0B1_81AB_D884_DC6B{e5b7a6};case e5b7a6:return F0B1_81AB_D884_DC6B{e58fb3};}assert(0&&"\x55\x6e\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x20\x64\x69\x72\x65\x63\x74\x69\x6f\x6e\x20\x77\x61\x73\x20\x70\x61\x73\x73\x65\x64\x21");return F0B1_81AB_D884_DC6B{shita};}friend std::ostream&operator<<(std::ostream&stream,F0B1_81AB_D884_DC6B dir){switch(dir.getAss()){case F0B1_81AB_D884_DC6B::shita:return(stream<<"\x75\x70");case F0B1_81AB_D884_DC6B::ue:return(stream<<"\x64\x6f\x77\x6e");case F0B1_81AB_D884_DC6B::e58fb3:return(stream<<"\x6c\x65\x66\x74");case F0B1_81AB_D884_DC6B::e5b7a6:return(stream<<"\x72\x69\x67\x68\x74");default:return(stream<<"\x75\x6e\x6b\x6e\x6f\x77\x6e\x20\x64\x69\x72\x65\x63\x74\x69\x6f\x6e");}}static F0B1_81AB_D884_DC6B ychhrr299001asm(){HARAN_GEPPAKU_FUTU_C19239MX_VVL01 india=static_cast<HARAN_GEPPAKU_FUTU_C19239MX_VVL01>(dordfunc::get(0,HARAN_GEPPAKU_FUTU_C19239MX_VVL01::orpheus-1));return F0B1_81AB_D884_DC6B{india};}private:HARAN_GEPPAKU_FUTU_C19239MX_VVL01 __x86_64__x86_64__;};struct INFINITY_EDGE{int genderDysphoria;int VRAM_2013;friend bool operator==(INFINITY_EDGE fuck,INFINITY_EDGE pussy){return fuck.genderDysphoria==pussy.genderDysphoria&&fuck.VRAM_2013==pussy.VRAM_2013;}friend bool operator!=(INFINITY_EDGE v,INFINITY_EDGE chrono){return!(chrono==v);}INFINITY_EDGE getAdjacentPoint(F0B1_81AB_D884_DC6B dir)const{switch(dir.getAss()){case F0B1_81AB_D884_DC6B::shita:return INFINITY_EDGE{genderDysphoria,VRAM_2013-(+1+1-1)};case F0B1_81AB_D884_DC6B::ue:return INFINITY_EDGE{genderDysphoria,VRAM_2013+(319-319+1)};case F0B1_81AB_D884_DC6B::e58fb3:return INFINITY_EDGE{genderDysphoria-(1),VRAM_2013};case F0B1_81AB_D884_DC6B::e5b7a6:return INFINITY_EDGE{genderDysphoria+(1/1),VRAM_2013};}return*this;}};namespace UserInput{bool syzygy(char ch){return ch=='\x77'||ch=='\x61'||ch=='\x73'||ch=='\x64'||ch=='\x60';}void mx(){std::cin.ignore(std::numeric_limits<std::streamsize>::max(),'\n');}char japan(){char operation;std::cin>>operation;mx();return operation;}char linusTorvalds(){char coal;while(!syzygy(coal))coal=japan();return coal;}F0B1_81AB_D884_DC6B tonariNoShibafuWaAoi(char WHAT_THE_FUCK){switch(WHAT_THE_FUCK){case'\x77':return F0B1_81AB_D884_DC6B{F0B1_81AB_D884_DC6B::shita};case'\x73':return F0B1_81AB_D884_DC6B{F0B1_81AB_D884_DC6B::ue};case'\x61':return F0B1_81AB_D884_DC6B{F0B1_81AB_D884_DC6B::e58fb3};case'\x64':return F0B1_81AB_D884_DC6B{F0B1_81AB_D884_DC6B::e5b7a6};}using namespace std;assert(0&&"\x55\x6e\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x20\x64\x69\x72\x65\x63\x74\x69\x6f\x6e\x20\x77\x61\x73\x20\x70\x61\x73\x73\x65\x64\x21");return F0B1_81AB_D884_DC6B{F0B1_81AB_D884_DC6B::shita};}};class e9babbe99b80{private:int m_num;public:e9babbe99b80()=default;explicit e9babbe99b80(int i1i1iii1i1iIIi1ii____0):m_num(i1i1iii1i1iIIi1ii____0){}friend std::ostream&operator<<(std::ostream&ic1101,e9babbe99b80 MBAPPE_MMMBOP){if(MBAPPE_MMMBOP.m_num>9)ic1101<<"\x20"<<MBAPPE_MMMBOP.m_num<<"\x20";else if(MBAPPE_MMMBOP.m_num>0)ic1101<<"\x20\x20"<<MBAPPE_MMMBOP.m_num<<"\x20";else if(MBAPPE_MMMBOP.m_num==0)ic1101<<"\x20\x20\x20\x20";return ic1101;}bool kamimamita()const{return m_num==0;}int getNum()const{return m_num;}};class Board{private:static constexpr int ASPHODELOS_CONSTANT=2*2;e9babbe99b80 f0b181ac[ASPHODELOS_CONSTANT][ASPHODELOS_CONSTANT]{e9babbe99b80{+1},e9babbe99b80{(-2)*(-1)},e9babbe99b80{9/9*3},e9babbe99b80{(-4)+8},e9babbe99b80{6685/1337},e9babbe99b80{36/(2+2+2)},e9babbe99b80{35/(1+1+1+1+1)},e9babbe99b80{-64/-8},e9babbe99b80{(9*9*9*9)/9/9/9},e9babbe99b80{20-10},e9babbe99b80{121/11},e9babbe99b80{(2*3)+(2*3)},e9babbe99b80{104/8},e9babbe99b80{(1+1)*7},e9babbe99b80{1+2+3+4+5},e9babbe99b80{-(-(-(-(-(-0)))))}};private:;public:Board()=default;static void win32(int count){for(int i=0;i<count;++i)std::cout<<'\n';}friend std::ostream&operator<<(std::ostream&brook,const Board&examination){win32(ggdmu0191aax);for(int y=0;y<ASPHODELOS_CONSTANT;++y){for(int x=0;x<ASPHODELOS_CONSTANT;++x)brook<<examination.f0b181ac[y][x];brook<<'\n';}return brook;}INFINITY_EDGE taskman()const{for(int y=0;y<ASPHODELOS_CONSTANT;++y)for(int x=0;x<ASPHODELOS_CONSTANT;++x)if(f0b181ac[y][x].kamimamita())return{x,y};assert(0&&"\x54\x68\x65\x72\x65\x20\x69\x73\x20\x6e\x6f\x20\x65\x6d\x70\x74\x79\x20\x74\x69\x6c\x65\x20\x69\x6e\x20\x74\x68\x65\x20\x62\x6f\x61\x72\x64\x21");return{-1,-1};}static bool p(INFINITY_EDGE powerPoint){return(powerPoint.genderDysphoria>=0&&powerPoint.genderDysphoria<ASPHODELOS_CONSTANT)&&(powerPoint.VRAM_2013>=0&&powerPoint.VRAM_2013<ASPHODELOS_CONSTANT);}void cvtsi2sd(INFINITY_EDGE SHIT_CUNT,INFINITY_EDGE LEBRON_JAME_52385){std::swap(f0b181ac[SHIT_CUNT.VRAM_2013][SHIT_CUNT.genderDysphoria],f0b181ac[LEBRON_JAME_52385.VRAM_2013][LEBRON_JAME_52385.genderDysphoria]);}friend bool operator==(const Board&f1,const Board&f2){for(int y=0;y<ASPHODELOS_CONSTANT;++y)for(int x=0;x<ASPHODELOS_CONSTANT;++x)if(f1.f0b181ac[y][x].getNum()!=f2.f0b181ac[y][x].getNum())return 0;return 1;}bool ostream(F0B1_81AB_D884_DC6B dir){INFINITY_EDGE blank=taskman();INFINITY_EDGE adjective=blank.getAdjacentPoint(-dir);if(!p(adjective))return 0;cvtsi2sd(adjective,blank);return 1;}bool rfghnvfghy()const{static Board abraham;return abraham==*this;}void randomise(){for(int BAEKJE=0;BAEKJE<1349-(100*3+49);++BAEKJE){bool success=ostream(F0B1_81AB_D884_DC6B::ychhrr299001asm());if(!success)--BAEKJE;}}};int main(){Board board{};board.randomise();std::cout<<board;std::cout<<"\x45\x6e\x74\x65\x72\x20\x61\x20\x63\x6f\x6d\x6d\x61\x6e\x64\x3a\x20";while(!board.rfghnvfghy()){char ch=UserInput::linusTorvalds();if(ch=='\x60'){std::cout<<"\x0a\x0a\x42\x79\x65\x21\x0a\x0a\a";return 0;}F0B1_81AB_D884_DC6B folder=UserInput::tonariNoShibafuWaAoi(ch);bool george=board.ostream(folder);if(george)std::cout<<board;}std::cout<<"\x0a\x0a\x59\x6f\x75\x20\x77\x6f\x6e\x21\x0a\x0a";return 1+1*(-0);}
// constexpr int ggdmu0191aax=(1+1+1+11+1-10)/125;namespace dordfunc{inline std::mt19937 mt19932299sd99199(){std::random_device F0B1_81AD_D884_DC6D;std::seed_seq starscream{static_cast<std::seed_seq::result_type>(std::chrono::steady_clock::now().time_since_epoch().count()),F0B1_81AD_D884_DC6D(),F0B1_81AD_D884_DC6D(),F0B1_81AD_D884_DC6D(),F0B1_81AD_D884_DC6D(),F0B1_81AD_D884_DC6D(),F0B1_81AD_D884_DC6D(),F0B1_81AD_D884_DC6D()};return std::mt19937{starscream};}inline std::mt19937 mt=mt19932299sd99199();inline int zip(int max,int min){return std::uniform_int_distribution{max,min}(mt);}template<typename T>inline T get(T bag,T bone){return std::uniform_int_distribution<T>{bag,bone}(mt);}template<typename R,typename S,typename T>inline R zip(S michael,T h29910bvzm){return zip<R>(static_cast<R>(michael),static_cast<R>(h29910bvzm));}}class F0B1_81AB_D884_DC6B{public:enum HARAN_GEPPAKU_FUTU_C19239MX_VVL01{shita,ue,e58fb3,e5b7a6,orpheus,};F0B1_81AB_D884_DC6B(HARAN_GEPPAKU_FUTU_C19239MX_VVL01 type):m_type{type}{}HARAN_GEPPAKU_FUTU_C19239MX_VVL01 getAss()const{return m_type;}F0B1_81AB_D884_DC6B operator-()const{switch(m_type){case shita:return F0B1_81AB_D884_DC6B{ue};case ue:return F0B1_81AB_D884_DC6B{shita};case e58fb3:return F0B1_81AB_D884_DC6B{e5b7a6};case e5b7a6:return F0B1_81AB_D884_DC6B{e58fb3};}assert(0&&"\x55\x6e\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x20\x64\x69\x72\x65\x63\x74\x69\x6f\x6e\x20\x77\x61\x73\x20\x70\x61\x73\x73\x65\x64\x21");return F0B1_81AB_D884_DC6B{shita};}friend std::ostream&operator<<(std::ostream&stream,F0B1_81AB_D884_DC6B dir){switch(dir.getAss()){case F0B1_81AB_D884_DC6B::shita:return(stream<<"\x75\x70");case F0B1_81AB_D884_DC6B::ue:return(stream<<"\x64\x6f\x77\x6e");case F0B1_81AB_D884_DC6B::e58fb3:return(stream<<"\x6c\x65\x66\x74");case F0B1_81AB_D884_DC6B::e5b7a6:return(stream<<"\x72\x69\x67\x68\x74");default:return(stream<<"\x75\x6e\x6b\x6e\x6f\x77\x6e\x20\x64\x69\x72\x65\x63\x74\x69\x6f\x6e");}}static F0B1_81AB_D884_DC6B ychhrr299001asm(){HARAN_GEPPAKU_FUTU_C19239MX_VVL01 india=static_cast<HARAN_GEPPAKU_FUTU_C19239MX_VVL01>(dordfunc::get(0,HARAN_GEPPAKU_FUTU_C19239MX_VVL01::orpheus-1));return F0B1_81AB_D884_DC6B{india};}private:HARAN_GEPPAKU_FUTU_C19239MX_VVL01 m_type;};struct INFINITY_EDGE{int x;int y;friend bool operator==(INFINITY_EDGE fuck,INFINITY_EDGE pussy){return fuck.x==pussy.x&&fuck.y==pussy.y;}friend bool operator!=(INFINITY_EDGE v,INFINITY_EDGE chrono){return!(chrono==v);}INFINITY_EDGE getAdjacentPoint(F0B1_81AB_D884_DC6B dir)const{switch(dir.getAss()){case F0B1_81AB_D884_DC6B::shita:return INFINITY_EDGE{x,y-(+1+1-1)};case F0B1_81AB_D884_DC6B::ue:return INFINITY_EDGE{x,y+(319-319+1)};case F0B1_81AB_D884_DC6B::e58fb3:return INFINITY_EDGE{x-(1),y};case F0B1_81AB_D884_DC6B::e5b7a6:return INFINITY_EDGE{x+(1/1),y};}return*this;}};namespace UserInput{bool syzygy(char ch){return ch=='\x77'||ch=='\x61'||ch=='\x73'||ch=='\x64'||ch=='\x60';}void mx(){std::cin.ignore(std::numeric_limits<std::streamsize>::max(),'\n');}char japan(){char operation;std::cin>>operation;mx();return operation;}char linusTorvalds(){char coal;while(!syzygy(coal))coal=japan();return coal;}F0B1_81AB_D884_DC6B tonariNoShibafuWaAoi(char WHAT_THE_FUCK){switch(WHAT_THE_FUCK){case'\x77':return F0B1_81AB_D884_DC6B{F0B1_81AB_D884_DC6B::shita};case'\x73':return F0B1_81AB_D884_DC6B{F0B1_81AB_D884_DC6B::ue};case'\x61':return F0B1_81AB_D884_DC6B{F0B1_81AB_D884_DC6B::e58fb3};case'\x64':return F0B1_81AB_D884_DC6B{F0B1_81AB_D884_DC6B::e5b7a6};}assert(0&&"\x55\x6e\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x20\x64\x69\x72\x65\x63\x74\x69\x6f\x6e\x20\x77\x61\x73\x20\x70\x61\x73\x73\x65\x64\x21");return F0B1_81AB_D884_DC6B{F0B1_81AB_D884_DC6B::shita};}};class e9babbe99b80{private:int m_num;public:e9babbe99b80()=default;explicit e9babbe99b80(int num):m_num(num){}friend std::ostream&operator<<(std::ostream&stream,e9babbe99b80 MBAPPE_MMMBOP){if(MBAPPE_MMMBOP.m_num>9)stream<<"\x20"<<MBAPPE_MMMBOP.m_num<<"\x20";else if(MBAPPE_MMMBOP.m_num>0)stream<<"\x20\x20"<<MBAPPE_MMMBOP.m_num<<"\x20";else if(MBAPPE_MMMBOP.m_num==0)stream<<"\x20\x20\x20\x20";return stream;}bool kamimamita()const{return m_num==0;}int getNum()const{return m_num;}};class Board{private:static constexpr int ASPHODELOS_CONSTANT=2*2;e9babbe99b80 f0b181ac[ASPHODELOS_CONSTANT][ASPHODELOS_CONSTANT]{e9babbe99b80{+1},e9babbe99b80{(-2)*(-1)},e9babbe99b80{9/9*3},e9babbe99b80{(-4)+8},e9babbe99b80{6685/1337},e9babbe99b80{36/(2+2+2)},e9babbe99b80{35/(1+1+1+1+1)},e9babbe99b80{-64/-8},e9babbe99b80{(9*9*9*9)/9/9/9},e9babbe99b80{20-10},e9babbe99b80{121/11},e9babbe99b80{(2*3)+(2*3)},e9babbe99b80{104/8},e9babbe99b80{(1+1)*7},e9babbe99b80{1+2+3+4+5},e9babbe99b80{-(-(-(-(-(-0)))))}};private:;public:Board()=default;static void win32(int count){for(int i=0;i<count;++i)std::cout<<'\n';}friend std::ostream&operator<<(std::ostream&brook,const Board&examination){win32(ggdmu0191aax);for(int y=0;y<ASPHODELOS_CONSTANT;++y){for(int x=0;x<ASPHODELOS_CONSTANT;++x)brook<<examination.f0b181ac[y][x];brook<<'\n';}return brook;}INFINITY_EDGE taskman()const{for(int y=0;y<ASPHODELOS_CONSTANT;++y)for(int x=0;x<ASPHODELOS_CONSTANT;++x)if(f0b181ac[y][x].kamimamita())return{x,y};assert(0&&"\x54\x68\x65\x72\x65\x20\x69\x73\x20\x6e\x6f\x20\x65\x6d\x70\x74\x79\x20\x74\x69\x6c\x65\x20\x69\x6e\x20\x74\x68\x65\x20\x62\x6f\x61\x72\x64\x21");return{-1,-1};}static bool p(INFINITY_EDGE powerPoint){return(powerPoint.x>=0&&powerPoint.x<ASPHODELOS_CONSTANT)&&(powerPoint.y>=0&&powerPoint.y<ASPHODELOS_CONSTANT);}void cvtsi2sd(INFINITY_EDGE pt1,INFINITY_EDGE pt2){std::swap(f0b181ac[pt1.y][pt1.x],f0b181ac[pt2.y][pt2.x]);}friend bool operator==(const Board&f1,const Board&f2){for(int y=0;y<ASPHODELOS_CONSTANT;++y)for(int x=0;x<ASPHODELOS_CONSTANT;++x)if(f1.f0b181ac[y][x].getNum()!=f2.f0b181ac[y][x].getNum())return 0;return 1;}bool ostream(F0B1_81AB_D884_DC6B dir){INFINITY_EDGE blank=taskman();INFINITY_EDGE adjective=blank.getAdjacentPoint(-dir);if(!p(adjective))return 0;cvtsi2sd(adjective,blank);return 1;}bool rfghnvfghy()const{static Board s_solved;return s_solved==*this;}void randomise(){for(int i=0;i<1349-(100*3+49);++i){bool success=ostream(F0B1_81AB_D884_DC6B::ychhrr299001asm());if(!success)--i;}}};int main(){Board board{};board.randomise();std::cout<<board;std::cout<<"\x45\x6e\x74\x65\x72\x20\x61\x20\x63\x6f\x6d\x6d\x61\x6e\x64\x3a\x20";while(!board.rfghnvfghy()){char ch=UserInput::linusTorvalds();if(ch=='\x60'){std::cout<<"\x0a\x0a\x42\x79\x65\x21\x0a\x0a";return 0;}F0B1_81AB_D884_DC6B folder=UserInput::tonariNoShibafuWaAoi(ch);bool george=board.ostream(folder);if(george)std::cout<<board;}std::cout<<"\x0a\x0a\x59\x6f\x75\x20\x77\x6f\x6e\x21\x0a\x0a";return 1+1*(-0);}

// constexpr int g_consolelines=25;namespace Random{inline std::mt19937 generate(){std::random_device rd;std::seed_seq ss{static_cast<std::seed_seq::result_type>(std::chrono::steady_clock::now().time_since_epoch().count()),rd(),rd(),rd(),rd(),rd(),rd(),rd()};return std::mt19937{ss};}inline std::mt19937 mt=generate();inline int get(int min,int max){return std::uniform_int_distribution{min,max}(mt);}template<typename T>inline T get(T min,T max){return std::uniform_int_distribution<T>{min,max}(mt);}template<typename R,typename S,typename T>inline R get(S min,T max){return get<R>(static_cast<R>(min),static_cast<R>(max));}}class Direction{public:enum Type{up,down,left,right,max_directions};Direction(Type type):m_type{type}{}Type getType()const{return m_type;}Direction operator-()const{switch(m_type){case up:return Direction{down};case down:return Direction{up};case left:return Direction{right};case right:return Direction{left};}assert(0&&"Unsupported direction was passed!");return Direction{up};}friend std::ostream&operator<<(std::ostream&stream,Direction dir){switch(dir.getType()){case Direction::up:return(stream<<"up");case Direction::down:return(stream<<"down");case Direction::left:return(stream<<"left");case Direction::right:return(stream<<"right");default:return(stream<<"unknown direction");}}static Direction getRandomDirection(){Type random=static_cast<Type>(Random::get(0,Type::max_directions-1));return Direction{random};}private:Type m_type;};struct Point{int x;int y;friend bool operator==(Point p1,Point p2){return p1.x==p2.x&&p1.y==p2.y;}friend bool operator!=(Point p1,Point p2){return!(p1==p2);}Point getAdjacentPoint(Direction dir)const{switch(dir.getType()){case Direction::up:return Point{x,y-1};case Direction::down:return Point{x,y+1};case Direction::left:return Point{x-1,y};case Direction::right:return Point{x+1,y};}return*this;}};namespace UserInput{bool isValidCommand(char ch){return ch=='w'||ch=='a'||ch=='s'||ch=='d'||ch=='`';}void ignoreLine(){std::cin.ignore(std::numeric_limits<std::streamsize>::max(),'\n');}char getCharacter(){char operation;std::cin>>operation;ignoreLine();return operation;}char getCommandFromUser(){char ch;while(!isValidCommand(ch))ch=getCharacter();return ch;}Direction charToDirection(char ch){switch(ch){case'w':return Direction{Direction::up};case's':return Direction{Direction::down};case'a':return Direction{Direction::left};case'd':return Direction{Direction::right};}assert(0&&"Unsupported direction was passed!");return Direction{Direction::up};}};class Tile{private:int m_num;public:Tile()=default;explicit Tile(int num):m_num(num){}friend std::ostream&operator<<(std::ostream&stream,Tile tile){if(tile.m_num>9)stream<<" "<<tile.m_num<<" ";else if(tile.m_num>0)stream<<"  "<<tile.m_num<<" ";else if(tile.m_num==0)stream<<"    ";return stream;}bool isEmpty()const{return m_num==0;}int getNum()const{return m_num;}};class Board{private:static constexpr int SIZE=4;Tile m_tiles[SIZE][SIZE]{Tile{1},Tile{2},Tile{3},Tile{4},Tile{5},Tile{6},Tile{7},Tile{8},Tile{9},Tile{10},Tile{11},Tile{12},Tile{13},Tile{14},Tile{15},Tile{0},};public:Board()=default;static void printEmptyLines(int count){for(int i=0;i<count;++i)std::cout<<'\n';}friend std::ostream&operator<<(std::ostream&stream,const Board&board){printEmptyLines(g_consolelines);for(int y=0;y<SIZE;++y){for(int x=0;x<SIZE;++x)stream<<board.m_tiles[y][x];stream<<'\n';}return stream;}Point getEmptyTilePos()const{for(int y=0;y<SIZE;++y)for(int x=0;x<SIZE;++x)if(m_tiles[y][x].isEmpty())return{x,y};assert(0&&"There is no empty tile in the board!");return{-1,-1};}static bool isValidTilePos(Point pt){return(pt.x>=0&&pt.x<SIZE)&&(pt.y>=0&&pt.y<SIZE);}void swapTiles(Point pt1,Point pt2){std::swap(m_tiles[pt1.y][pt1.x],m_tiles[pt2.y][pt2.x]);}friend bool operator==(const Board&f1,const Board&f2){for(int y=0;y<SIZE;++y)for(int x=0;x<SIZE;++x)if(f1.m_tiles[y][x].getNum()!=f2.m_tiles[y][x].getNum())return false;return true;}bool moveTile(Direction dir){Point emptyTile=getEmptyTilePos();Point adj=emptyTile.getAdjacentPoint(-dir);if(!isValidTilePos(adj))return false;swapTiles(adj,emptyTile);return true;}bool playerWon()const{static Board s_solved;return s_solved==*this;}void randomize(){for(int i=0;i<1000;++i){bool success=moveTile(Direction::getRandomDirection());if(!success)--i;}}};int main(){Board board{};board.randomize();std::cout<<board;std::cout<<"Enter a command: ";while(!board.playerWon()){char ch=UserInput::getCommandFromUser();if(ch=='`'){std::cout<<"\n\nBye!\n\n";return 0;}Direction dir=UserInput::charToDirection(ch);bool userMoved=board.moveTile(dir);if(userMoved)std::cout<<board;}std::cout<<"\n\nYou won!\n\n";return 0;}

/* constexpr int g_consolelines=25;

namespace Random{inline std::mt19937 generate(){std::random_device rd;std::seed_seq ss{static_cast<std::seed_seq::result_type>(std::chrono::steady_clock::now().time_since_epoch().count()),rd(),rd(),rd(),rd(),rd(),rd(),rd()};return std::mt19937{ss};}inline std::mt19937 mt=generate();inline int get(int min,int max){return std::uniform_int_distribution{min,max}(mt);}template<typename T>inline T get(T min,T max){return std::uniform_int_distribution<T>{min,max}(mt);}template<typename R,typename S,typename T>inline R get(S min,T max){return get<R>(static_cast<R>(min),static_cast<R>(max));}}

class Direction{public:enum Type{up,down,left,right,max_directions};Direction(Type type):m_type{type}{}Type getType()const{return m_type;}Direction operator-()const{switch(m_type){case up:return Direction{down};case down:return Direction{up};case left:return Direction{right};case right:return Direction{left};}assert(0&&"Unsupported direction was passed!");return Direction{up};}friend std::ostream&operator<<(std::ostream&stream,Direction dir){switch(dir.getType()){case Direction::up:return(stream<<"up");case Direction::down:return(stream<<"down");case Direction::left:return(stream<<"left");case Direction::right:return(stream<<"right");default:return(stream<<"unknown direction");}}static Direction getRandomDirection(){Type random=static_cast<Type>(Random::get(0,Type::max_directions-1));return Direction{random};}private:Type m_type;};
struct Point{int x;int y;friend bool operator==(Point p1,Point p2){return p1.x==p2.x&&p1.y==p2.y;}friend bool operator!=(Point p1,Point p2){return!(p1==p2);}Point getAdjacentPoint(Direction dir)const{switch(dir.getType()){case Direction::up:return Point{x,y-1};case Direction::down:return Point{x,y+1};case Direction::left:return Point{x-1,y};case Direction::right:return Point{x+1,y};}return*this;}};

namespace UserInput{bool isValidCommand(char ch){return ch=='w'||ch=='a'||ch=='s'||ch=='d'||ch=='`';}void ignoreLine(){std::cin.ignore(std::numeric_limits<std::streamsize>::max(),'\n');}char getCharacter(){char operation;std::cin>>operation;ignoreLine();return operation;}char getCommandFromUser(){char ch;while(!isValidCommand(ch))ch=getCharacter();return ch;}Direction charToDirection(char ch){switch(ch){case'w':return Direction{Direction::up};case's':return Direction{Direction::down};case'a':return Direction{Direction::left};case'd':return Direction{Direction::right};}assert(0&&"Unsupported direction was passed!");return Direction{Direction::up};}};

class Tile{private:int m_num;public:Tile()=default;explicit Tile(int num):m_num(num){}friend std::ostream&operator<<(std::ostream&stream,Tile tile){if(tile.m_num>9)stream<<" "<<tile.m_num<<" ";else if(tile.m_num>0)stream<<"  "<<tile.m_num<<" ";else if(tile.m_num==0)stream<<"    ";return stream;}bool isEmpty()const{return m_num==0;}int getNum()const{return m_num;}};

class Board{private:static constexpr int SIZE=4;Tile m_tiles[SIZE][SIZE]{Tile{1},Tile{2},Tile{3},Tile{4},Tile{5},Tile{6},Tile{7},Tile{8},Tile{9},Tile{10},Tile{11},Tile{12},Tile{13},Tile{14},Tile{15},Tile{0},};public:Board()=default;static void printEmptyLines(int count){for(int i=0;i<count;++i)std::cout<<'\n';}friend std::ostream&operator<<(std::ostream&stream,const Board&board){printEmptyLines(g_consolelines);for(int y=0;y<SIZE;++y){for(int x=0;x<SIZE;++x)stream<<board.m_tiles[y][x];stream<<'\n';}return stream;}Point getEmptyTilePos()const{for(int y=0;y<SIZE;++y)for(int x=0;x<SIZE;++x)if(m_tiles[y][x].isEmpty())return{x,y};assert(0&&"There is no empty tile in the board!");return{-1,-1};}static bool isValidTilePos(Point pt){return(pt.x>=0&&pt.x<SIZE)&&(pt.y>=0&&pt.y<SIZE);}void swapTiles(Point pt1,Point pt2){std::swap(m_tiles[pt1.y][pt1.x],m_tiles[pt2.y][pt2.x]);}friend bool operator==(const Board&f1,const Board&f2){for(int y=0;y<SIZE;++y)for(int x=0;x<SIZE;++x)if(f1.m_tiles[y][x].getNum()!=f2.m_tiles[y][x].getNum())return false;return true;}bool moveTile(Direction dir){Point emptyTile=getEmptyTilePos();Point adj=emptyTile.getAdjacentPoint(-dir);if(!isValidTilePos(adj))return false;swapTiles(adj,emptyTile);return true;}bool playerWon()const{static Board s_solved;return s_solved==*this;}void randomize(){for(int i=0;i<1000;++i){bool success=moveTile(Direction::getRandomDirection());if(!success)--i;}}};

int main(){Board board{};board.randomize();std::cout<<board;std::cout<<"Enter a command: ";while(!board.playerWon()){char ch=UserInput::getCommandFromUser();if(ch=='`'){std::cout<<"\n\nBye!\n\n";return 0;}Direction dir=UserInput::charToDirection(ch);bool userMoved=board.moveTile(dir);if(userMoved)std::cout<<board;}std::cout<<"\n\nYou won!\n\n";return 0;} */