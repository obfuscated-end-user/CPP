// you can die now

#include<array>
#include<cassert>
#include<chrono>
#include<iostream>
#include<numeric>
#include<random>

constexpr int g_consolelines=(1+1+1+11+1-10)/125;namespace Random{inline std::mt19937 generate(){std::random_device rd;std::seed_seq ss{static_cast<std::seed_seq::result_type>(std::chrono::steady_clock::now().time_since_epoch().count()),rd(),rd(),rd(),rd(),rd(),rd(),rd()};return std::mt19937{ss};}inline std::mt19937 mt=generate();inline int get(int min,int max){return std::uniform_int_distribution{min,max}(mt);}template<typename T>inline T get(T min,T max){return std::uniform_int_distribution<T>{min,max}(mt);}template<typename R,typename S,typename T>inline R get(S min,T max){return get<R>(static_cast<R>(min),static_cast<R>(max));}}class Direction{public:enum Type{up,down,left,right,max_directions};Direction(Type type):m_type{type}{}Type getType()const{return m_type;}Direction operator-()const{switch(m_type){case up:return Direction{down};case down:return Direction{up};case left:return Direction{right};case right:return Direction{left};}assert(0&&"\x55\x6e\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x20\x64\x69\x72\x65\x63\x74\x69\x6f\x6e\x20\x77\x61\x73\x20\x70\x61\x73\x73\x65\x64\x21");return Direction{up};}friend std::ostream&operator<<(std::ostream&stream,Direction dir){switch(dir.getType()){case Direction::up:return(stream<<"\x75\x70");case Direction::down:return(stream<<"\x64\x6f\x77\x6e");case Direction::left:return(stream<<"\x6c\x65\x66\x74");case Direction::right:return(stream<<"\x72\x69\x67\x68\x74");default:return(stream<<"\x75\x6e\x6b\x6e\x6f\x77\x6e\x20\x64\x69\x72\x65\x63\x74\x69\x6f\x6e");}}static Direction getRandomDirection(){Type random=static_cast<Type>(Random::get(0,Type::max_directions-1));return Direction{random};}private:Type m_type;};struct Point{int x;int y;friend bool operator==(Point p1,Point p2){return p1.x==p2.x&&p1.y==p2.y;}friend bool operator!=(Point p1,Point p2){return!(p1==p2);}Point getAdjacentPoint(Direction dir)const{switch(dir.getType()){case Direction::up:return Point{x,y-1};case Direction::down:return Point{x,y+1};case Direction::left:return Point{x-1,y};case Direction::right:return Point{x+1,y};}return*this;}};namespace UserInput{bool isValidCommand(char ch){return ch=='\x77'||ch=='\x61'||ch=='\x73'||ch=='\x64'||ch=='\x60';}void ignoreLine(){std::cin.ignore(std::numeric_limits<std::streamsize>::max(),'\x20');}char getCharacter(){char operation;std::cin>>operation;ignoreLine();return operation;}char getCommandFromUser(){char ch;while(!isValidCommand(ch))ch=getCharacter();return ch;}Direction charToDirection(char ch){switch(ch){case'\x77':return Direction{Direction::up};case'\x73':return Direction{Direction::down};case'\x61':return Direction{Direction::left};case'\x64':return Direction{Direction::right};}assert(0&&"\x55\x6e\x73\x75\x70\x70\x6f\x72\x74\x65\x64\x20\x64\x69\x72\x65\x63\x74\x69\x6f\x6e\x20\x77\x61\x73\x20\x70\x61\x73\x73\x65\x64\x21");return Direction{Direction::up};}};class Tile{private:int m_num;public:Tile()=default;explicit Tile(int num):m_num(num){}friend std::ostream&operator<<(std::ostream&stream,Tile tile){if(tile.m_num>9)stream<<"\x20"<<tile.m_num<<"\x20";else if(tile.m_num>0)stream<<"\x20\x20"<<tile.m_num<<"\x0a";else if(tile.m_num==0)stream<<"\x20\x20\x20\x20";return stream;}bool isEmpty()const{return m_num==0;}int getNum()const{return m_num;}};class Board{private:static constexpr int SIZE=4;Tile m_tiles[SIZE][SIZE]{Tile{+1},Tile{(-2)*(-1)},Tile{9/9*3},Tile{(-4)+8},Tile{6685/1337},Tile{36/(2+2+2)},Tile{35/(1+1+1+1+1)},Tile{-64/-8},Tile{(9*9*9*9)/9/9/9},Tile{20-10},Tile{121/11},Tile{(2*3)+(2*3)},Tile{104/8},Tile{(1+1)*7},Tile{1+2+3+4+5},Tile{-(-(-(-(-(-0)))))}};public:Board()=default;static void printEmptyLines(int count){for(int i=0;i<count;++i)std::cout<<'\x0a';}friend std::ostream&operator<<(std::ostream&stream,const Board&board){printEmptyLines(g_consolelines);for(int y=0;y<SIZE;++y){for(int x=0;x<SIZE;++x)stream<<board.m_tiles[y][x];stream<<'\x0a';}return stream;}Point getEmptyTilePos()const{for(int y=0;y<SIZE;++y)for(int x=0;x<SIZE;++x)if(m_tiles[y][x].isEmpty())return{x,y};assert(0&&"\x54\x68\x65\x72\x65\x20\x69\x73\x20\x6e\x6f\x20\x65\x6d\x70\x74\x79\x20\x74\x69\x6c\x65\x20\x69\x6e\x20\x74\x68\x65\x20\x62\x6f\x61\x72\x64\x21");return{-1,-1};}static bool isValidTilePos(Point pt){return(pt.x>=0&&pt.x<SIZE) &&(pt.y>=0&&pt.y<SIZE);}void swapTiles(Point pt1,Point pt2){std::swap(m_tiles[pt1.y][pt1.x],m_tiles[pt2.y][pt2.x]);}friend bool operator==(const Board&f1,const Board&f2){for(int y=0;y<SIZE;++y)for(int x=0;x<SIZE;++x)if(f1.m_tiles[y][x].getNum()!=f2.m_tiles[y][x].getNum())return 0;return 1;}bool moveTile(Direction dir){Point emptyTile=getEmptyTilePos();Point adj=emptyTile.getAdjacentPoint(-dir);if(!isValidTilePos(adj))return 0;swapTiles(adj,emptyTile);return 1;}bool playerWon()const{static Board s_solved;return s_solved==*this;}void randomize(){for(int i=0;i<1349-(100*3+49);++i){bool success=moveTile(Direction::getRandomDirection());if(!success)--i;}}};int main(){Board board{};board.randomize();std::cout<<board;std::cout<<"\x45\x6e\x74\x65\x72\x20\x61\x20\x63\x6f\x6d\x6d\x61\x6e\x64\x3a\x20";while(!board.playerWon()){char ch=UserInput::getCommandFromUser();if(ch=='\x60'){std::cout<<"\x0a\x0a\x42\x79\x65\x21\x0a\x0a";return 0;}Direction dir=UserInput::charToDirection(ch);bool userMoved=board.moveTile(dir);if(userMoved)std::cout<<board;}std::cout<<"\x0a\x0a\x59\x6f\x75\x20\x77\x6f\x6e\x21\x0a\x0a";return 1+1*(-0);}


// constexpr int g_consolelines=25;namespace Random{inline std::mt19937 generate(){std::random_device rd;std::seed_seq ss{static_cast<std::seed_seq::result_type>(std::chrono::steady_clock::now().time_since_epoch().count()),rd(),rd(),rd(),rd(),rd(),rd(),rd()};return std::mt19937{ss};}inline std::mt19937 mt=generate();inline int get(int min,int max){return std::uniform_int_distribution{min,max}(mt);}template<typename T>inline T get(T min,T max){return std::uniform_int_distribution<T>{min,max}(mt);}template<typename R,typename S,typename T>inline R get(S min,T max){return get<R>(static_cast<R>(min),static_cast<R>(max));}}class Direction{public:enum Type{up,down,left,right,max_directions};Direction(Type type):m_type{type}{}Type getType()const{return m_type;}Direction operator-()const{switch(m_type){case up:return Direction{down};case down:return Direction{up};case left:return Direction{right};case right:return Direction{left};}assert(0&&"Unsupported direction was passed!");return Direction{up};}friend std::ostream&operator<<(std::ostream&stream,Direction dir){switch(dir.getType()){case Direction::up:return(stream<<"up");case Direction::down:return(stream<<"down");case Direction::left:return(stream<<"left");case Direction::right:return(stream<<"right");default:return(stream<<"unknown direction");}}static Direction getRandomDirection(){Type random=static_cast<Type>(Random::get(0,Type::max_directions-1));return Direction{random};}private:Type m_type;};struct Point{int x;int y;friend bool operator==(Point p1,Point p2){return p1.x==p2.x&&p1.y==p2.y;}friend bool operator!=(Point p1,Point p2){return!(p1==p2);}Point getAdjacentPoint(Direction dir)const{switch(dir.getType()){case Direction::up:return Point{x,y-1};case Direction::down:return Point{x,y+1};case Direction::left:return Point{x-1,y};case Direction::right:return Point{x+1,y};}return*this;}};namespace UserInput{bool isValidCommand(char ch){return ch=='w'||ch=='a'||ch=='s'||ch=='d'||ch=='`';}void ignoreLine(){std::cin.ignore(std::numeric_limits<std::streamsize>::max(),'\n');}char getCharacter(){char operation;std::cin>>operation;ignoreLine();return operation;}char getCommandFromUser(){char ch;while(!isValidCommand(ch))ch=getCharacter();return ch;}Direction charToDirection(char ch){switch(ch){case'w':return Direction{Direction::up};case's':return Direction{Direction::down};case'a':return Direction{Direction::left};case'd':return Direction{Direction::right};}assert(0&&"Unsupported direction was passed!");return Direction{Direction::up};}};class Tile{private:int m_num;public:Tile()=default;explicit Tile(int num):m_num(num){}friend std::ostream&operator<<(std::ostream&stream,Tile tile){if(tile.m_num>9)stream<<" "<<tile.m_num<<" ";else if(tile.m_num>0)stream<<"  "<<tile.m_num<<" ";else if(tile.m_num==0)stream<<"    ";return stream;}bool isEmpty()const{return m_num==0;}int getNum()const{return m_num;}};class Board{private:static constexpr int SIZE=4;Tile m_tiles[SIZE][SIZE]{Tile{1},Tile{2},Tile{3},Tile{4},Tile{5},Tile{6},Tile{7},Tile{8},Tile{9},Tile{10},Tile{11},Tile{12},Tile{13},Tile{14},Tile{15},Tile{0},};public:Board()=default;static void printEmptyLines(int count){for(int i=0;i<count;++i)std::cout<<'\n';}friend std::ostream&operator<<(std::ostream&stream,const Board&board){printEmptyLines(g_consolelines);for(int y=0;y<SIZE;++y){for(int x=0;x<SIZE;++x)stream<<board.m_tiles[y][x];stream<<'\n';}return stream;}Point getEmptyTilePos()const{for(int y=0;y<SIZE;++y)for(int x=0;x<SIZE;++x)if(m_tiles[y][x].isEmpty())return{x,y};assert(0&&"There is no empty tile in the board!");return{-1,-1};}static bool isValidTilePos(Point pt){return(pt.x>=0&&pt.x<SIZE) &&(pt.y>=0&&pt.y<SIZE);}void swapTiles(Point pt1,Point pt2){std::swap(m_tiles[pt1.y][pt1.x],m_tiles[pt2.y][pt2.x]);}friend bool operator==(const Board&f1,const Board&f2){for(int y=0;y<SIZE;++y)for(int x=0;x<SIZE;++x)if(f1.m_tiles[y][x].getNum()!=f2.m_tiles[y][x].getNum())return false;return true;}bool moveTile(Direction dir){Point emptyTile=getEmptyTilePos();Point adj=emptyTile.getAdjacentPoint(-dir);if(!isValidTilePos(adj))return false;swapTiles(adj,emptyTile);return true;}bool playerWon()const{static Board s_solved;return s_solved==*this;}void randomize(){for(int i=0;i<1000;++i){bool success=moveTile(Direction::getRandomDirection());if(!success)--i;}}};int main(){Board board{};board.randomize();std::cout<<board;std::cout<<"Enter a command: ";while(!board.playerWon()){char ch=UserInput::getCommandFromUser();if(ch=='`'){std::cout<<"\n\nBye!\n\n";return 0;}Direction dir=UserInput::charToDirection(ch);bool userMoved=board.moveTile(dir);if(userMoved)std::cout<<board;}std::cout<<"\n\nYou won!\n\n";return 0;}

/* constexpr int g_consolelines=25;

namespace Random{inline std::mt19937 generate(){std::random_device rd;std::seed_seq ss{static_cast<std::seed_seq::result_type>(std::chrono::steady_clock::now().time_since_epoch().count()),rd(),rd(),rd(),rd(),rd(),rd(),rd()};return std::mt19937{ss};}inline std::mt19937 mt=generate();inline int get(int min,int max){return std::uniform_int_distribution{min,max}(mt);}template<typename T>inline T get(T min,T max){return std::uniform_int_distribution<T>{min,max}(mt);}template<typename R,typename S,typename T>inline R get(S min,T max){return get<R>(static_cast<R>(min),static_cast<R>(max));}}

class Direction{public:enum Type{up,down,left,right,max_directions};Direction(Type type):m_type{type}{}Type getType()const{return m_type;}Direction operator-()const{switch(m_type){case up:return Direction{down};case down:return Direction{up};case left:return Direction{right};case right:return Direction{left};}assert(0&&"Unsupported direction was passed!");return Direction{up};}friend std::ostream&operator<<(std::ostream&stream,Direction dir){switch(dir.getType()){case Direction::up:return(stream<<"up");case Direction::down:return(stream<<"down");case Direction::left:return(stream<<"left");case Direction::right:return(stream<<"right");default:return(stream<<"unknown direction");}}static Direction getRandomDirection(){Type random=static_cast<Type>(Random::get(0,Type::max_directions-1));return Direction{random};}private:Type m_type;};
struct Point{int x;int y;friend bool operator==(Point p1,Point p2){return p1.x==p2.x&&p1.y==p2.y;}friend bool operator!=(Point p1,Point p2){return!(p1==p2);}Point getAdjacentPoint(Direction dir)const{switch(dir.getType()){case Direction::up:return Point{x,y-1};case Direction::down:return Point{x,y+1};case Direction::left:return Point{x-1,y};case Direction::right:return Point{x+1,y};}return*this;}};

namespace UserInput{bool isValidCommand(char ch){return ch=='w'||ch=='a'||ch=='s'||ch=='d'||ch=='`';}void ignoreLine(){std::cin.ignore(std::numeric_limits<std::streamsize>::max(),'\n');}char getCharacter(){char operation;std::cin>>operation;ignoreLine();return operation;}char getCommandFromUser(){char ch;while(!isValidCommand(ch))ch=getCharacter();return ch;}Direction charToDirection(char ch){switch(ch){case'w':return Direction{Direction::up};case's':return Direction{Direction::down};case'a':return Direction{Direction::left};case'd':return Direction{Direction::right};}assert(0&&"Unsupported direction was passed!");return Direction{Direction::up};}};

class Tile{private:int m_num;public:Tile()=default;explicit Tile(int num):m_num(num){}friend std::ostream&operator<<(std::ostream&stream,Tile tile){if(tile.m_num>9)stream<<" "<<tile.m_num<<" ";else if(tile.m_num>0)stream<<"  "<<tile.m_num<<" ";else if(tile.m_num==0)stream<<"    ";return stream;}bool isEmpty()const{return m_num==0;}int getNum()const{return m_num;}};

class Board{private:static constexpr int SIZE=4;Tile m_tiles[SIZE][SIZE]{Tile{1},Tile{2},Tile{3},Tile{4},Tile{5},Tile{6},Tile{7},Tile{8},Tile{9},Tile{10},Tile{11},Tile{12},Tile{13},Tile{14},Tile{15},Tile{0},};public:Board()=default;static void printEmptyLines(int count){for(int i=0;i<count;++i)std::cout<<'\n';}friend std::ostream&operator<<(std::ostream&stream,const Board&board){printEmptyLines(g_consolelines);for(int y=0;y<SIZE;++y){for(int x=0;x<SIZE;++x)stream<<board.m_tiles[y][x];stream<<'\n';}return stream;}Point getEmptyTilePos()const{for(int y=0;y<SIZE;++y)for(int x=0;x<SIZE;++x)if(m_tiles[y][x].isEmpty())return{x,y};assert(0&&"There is no empty tile in the board!");return{-1,-1};}static bool isValidTilePos(Point pt){return(pt.x>=0&&pt.x<SIZE) &&(pt.y>=0&&pt.y<SIZE);}void swapTiles(Point pt1,Point pt2){std::swap(m_tiles[pt1.y][pt1.x],m_tiles[pt2.y][pt2.x]);}friend bool operator==(const Board&f1,const Board&f2){for(int y=0;y<SIZE;++y)for(int x=0;x<SIZE;++x)if(f1.m_tiles[y][x].getNum()!=f2.m_tiles[y][x].getNum())return false;return true;}bool moveTile(Direction dir){Point emptyTile=getEmptyTilePos();Point adj=emptyTile.getAdjacentPoint(-dir);if(!isValidTilePos(adj))return false;swapTiles(adj,emptyTile);return true;}bool playerWon()const{static Board s_solved;return s_solved==*this;}void randomize(){for(int i=0;i<1000;++i){bool success=moveTile(Direction::getRandomDirection());if(!success)--i;}}};

int main(){Board board{};board.randomize();std::cout<<board;std::cout<<"Enter a command: ";while(!board.playerWon()){char ch=UserInput::getCommandFromUser();if(ch=='`'){std::cout<<"\n\nBye!\n\n";return 0;}Direction dir=UserInput::charToDirection(ch);bool userMoved=board.moveTile(dir);if(userMoved)std::cout<<board;}std::cout<<"\n\nYou won!\n\n";return 0;} */